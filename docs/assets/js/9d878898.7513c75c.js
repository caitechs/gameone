"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8063],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),g=l(n),u=r,m=g["".concat(d,".").concat(u)]||g[u]||p[u]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s[g]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4910:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(83117),r=(n(67294),n(3905));const o={title:"Edged",sidebar_position:1},i=void 0,s={unversionedId:"architecture/edge/edged",id:"architecture/edge/edged",title:"Edged",description:"Overview",source:"@site/i18n/zh/docusaurus-plugin-content-docs/current/architecture/edge/edged.md",sourceDirName:"architecture/edge",slug:"/architecture/edge/edged",permalink:"/gameone/docs/architecture/edge/edged",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Edged",sidebar_position:1},sidebar:"documentationSideBar",previous:{title:"Edge Components",permalink:"/gameone/docs/category/edge-components"},next:{title:"EventBus",permalink:"/gameone/docs/architecture/edge/eventbus"}},d={},l=[{value:"Overview",id:"overview",level:2},{value:"Pod Management",id:"pod-management",level:2},{value:"Pod Lifecycle Event Generator",id:"pod-lifecycle-event-generator",level:2},{value:"CRI for edged",id:"cri-for-edged",level:2},{value:"Why CRI for edged?",id:"why-cri-for-edged",level:4},{value:"Secret Management",id:"secret-management",level:2},{value:"Probe Management",id:"probe-management",level:2},{value:"ConfigMap Management",id:"configmap-management",level:2},{value:"Container GC",id:"container-gc",level:2},{value:"Image GC",id:"image-gc",level:2},{value:"Status Manager",id:"status-manager",level:2},{value:"Volume Management",id:"volume-management",level:2},{value:"MetaClient",id:"metaclient",level:2}],c={toc:l},g="wrapper";function p(e){let{components:t,...o}=e;return(0,r.kt)(g,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"EdgeD is an edge node module which manages pod lifecycle. It helps users to deploy containerized workloads or applications at the edge node. Those workloads could perform any operation from simple telemetry data manipulation to analytics or ML inference and so on. Using ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl")," command line interface at the cloud side, users can issue commands to launch the workloads."),(0,r.kt)("p",null,"Several OCI-compliant runtimes are supported through the Container Runtime Interface (CRI). See ",(0,r.kt)("a",{parentName:"p",href:"/gameone/docs/setup/prerequisites/runtime"},"KubeEdge runtime configuration")," for more information on how to configure edged to make use of other runtimes."),(0,r.kt)("p",null,"There are many modules which work in tandem to achieve edged's functionalities."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"EdgeD Overall",src:n(78254).Z,width:"663",height:"403"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 1: EdgeD Functionalities")),(0,r.kt)("h2",{id:"pod-management"},"Pod Management"),(0,r.kt)("p",null,"It is handles for pod addition, deletion and modification. It also tracks the health of the pods using pod status manager and pleg.\nIts primary jobs are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Receives and handles pod addition/deletion/modification messages from metamanager."),(0,r.kt)("li",{parentName:"ul"},"Handles separate worker queues for pod addition and deletion."),(0,r.kt)("li",{parentName:"ul"},"Handles worker routines to check worker queues to do pod operations."),(0,r.kt)("li",{parentName:"ul"},"Keeps separate cache for config map and secrets respectively."),(0,r.kt)("li",{parentName:"ul"},"Regular cleanup of orphaned pods")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Pod Addition Flow",src:n(38709).Z,width:"1326",height:"696"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 2: Pod Addition Flow")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Pod Deletion Flow",src:n(43652).Z,width:"1028",height:"459"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 3: Pod Deletion Flow")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Pod Updation Flow",src:n(53930).Z,width:"1306",height:"766"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 4: Pod Updation Flow")),(0,r.kt)("h2",{id:"pod-lifecycle-event-generator"},"Pod Lifecycle Event Generator"),(0,r.kt)("p",null,"This module helps in monitoring pod status for edged. Every second, using probes for liveness and readiness, it updates the information with pod status manager for every pod."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"PLEG Design",src:n(87763).Z,width:"1159",height:"503"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 5: PLEG at EdgeD")),(0,r.kt)("h2",{id:"cri-for-edged"},"CRI for edged"),(0,r.kt)("p",null,"Container Runtime Interface (CRI) \u2013 a plugin interface which enables edged to use a wide variety of container runtimes like Docker, containerd, CRI-O, etc., without the need to recompile. For more on how to configure KubeEdge for container runtimes, see ",(0,r.kt)("a",{parentName:"p",href:"../../setup/prerequisites/runtime"},"KubeEdge runtime configuration"),"."),(0,r.kt)("h4",{id:"why-cri-for-edged"},"Why CRI for edged?"),(0,r.kt)("p",null,"CRI support for multiple container runtimes in edged is needed in order to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Support light-weight container runtimes on resource-constrained edge nodes which are unable to run the existing Docker runtime."),(0,r.kt)("li",{parentName:"ul"},"Support multiple container runtimes like Docker, containerd, CRI-O, etc., on edge nodes.")),(0,r.kt)("p",null,"Support for corresponding CNI with pause container and IP will be considered later."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"CRI Design",src:n(45140).Z,width:"954",height:"305"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 6: CRI at EdgeD")),(0,r.kt)("h2",{id:"secret-management"},"Secret Management"),(0,r.kt)("p",null,"In edged, Secrets are handled separately. For operations like addition, deletion and modification, there are separate sets of config messages and interfaces.\nUsing these interfaces, secrets are updated in cache store.\nThe flow diagram below explains the message flow."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Secret Message Handling",src:n(66741).Z,width:"1130",height:"508"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 7: Secret Message Handling at EdgeD")),(0,r.kt)("p",null,"Edged uses the MetaClient module to fetch secrets from MetaManager. If edged queries for a new secret which is not yet stored in MetaManager, the request is forwarded to the Cloud. Before sending the response containing the secret, MetaManager stores it in a local database. Subsequent queries for the same secret key will be retrieved from the database, reducing latency. The flow diagram below shows how a secret is fetched from MetaManager and the Cloud. It also descibes how the secret is stored in MetaManager."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Query Secret",src:n(21450).Z,width:"1065",height:"619"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 8: Query Secret by EdgeD")),(0,r.kt)("h2",{id:"probe-management"},"Probe Management"),(0,r.kt)("p",null,"Probe management creates two probes for readiness and liveness respectively for pods to monitor the containers. The readiness probe helps by monitoring when the pod has reached a running state. The liveness probe helps by monitoring the health of pods, indicating if they are up or down.\nAs explained earlier, the PLEG module uses its services."),(0,r.kt)("h2",{id:"configmap-management"},"ConfigMap Management"),(0,r.kt)("p",null,"In edged, ConfigMaps are also handled separately. For operations like addition, deletion and modification, there are separate sets of config messages and interfaces.\nUsing these interfaces, ConfigMaps are updated in cache store.\nThe flow diagram below explains the message flow."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"ConfigMap Message Handling",src:n(82552).Z,width:"1126",height:"481"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 9: ConfigMap Message Handling at EdgeD")),(0,r.kt)("p",null,"Edged uses the MetaClient module to fetch ConfigMaps from MetaManager. If edged queries for a new ConfigMap which is not yet stored in MetaManager, the request is forwarded to the Cloud. Before sending the response containing the ConfigMap, MetaManager stores it in a local database. Subsequent queries for the same ConfigMap key will be retrieved from the database, reducing latency. The flow diagram below shows how ConfigMaps are fetched from MetaManager and the Cloud. It also descibes how ConfigMaps are stored in MetaManager."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Query Configmaps",src:n(85420).Z,width:"1183",height:"504"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 10: Query Configmaps by EdgeD")),(0,r.kt)("h2",{id:"container-gc"},"Container GC"),(0,r.kt)("p",null,"The container garbage collector is an edged routine which wakes up every minute, collecting and removing dead containers using the specified container gc policy.\nThe policy for garbage collecting containers is determined by three variables, which can be user-defined:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MinAge")," is the minimum age at which a container can be garbage collected, zero for no limit."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MaxPerPodContainer")," is the maximum number of dead containers that any single pod (UID, container name) pair is allowed to have, less than zero for no limit."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MaxContainers")," is the maximum number of total dead containers, less than zero for no limit. Generally, the oldest containers are removed first.")),(0,r.kt)("h2",{id:"image-gc"},"Image GC"),(0,r.kt)("p",null,"The image garbage collector is an edged routine which wakes up every 5 secs, and collects information about disk usage based on the policy used.\nThe policy for garbage collecting images takes two factors into consideration, ",(0,r.kt)("inlineCode",{parentName:"p"},"HighThresholdPercent")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LowThresholdPercent"),". Disk usage above the high threshold will trigger garbage collection, which attempts to delete unused images until the low threshold is met. Least recently used images are deleted first."),(0,r.kt)("h2",{id:"status-manager"},"Status Manager"),(0,r.kt)("p",null,"Status manager is an independent edge routine, which collects pods statuses every 10 seconds and forwards this information to the cloud using the metaclient interface."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Status Manager Flow",src:n(53122).Z,width:"1213",height:"612"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Fig 11: Status Manager Flow")),(0,r.kt)("h2",{id:"volume-management"},"Volume Management"),(0,r.kt)("p",null,"Volume manager runs as an edge routine which brings out the information of which volume(s) are to be attached/mounted/unmounted/detached based on pods scheduled on the edge node."),(0,r.kt)("p",null,"Before starting the pod, all the specified volumes referenced in pod specs are attached and mounted, Till then the flow is blocked and with it other operations."),(0,r.kt)("h2",{id:"metaclient"},"MetaClient"),(0,r.kt)("p",null,"Metaclient is an interface of Metamanger for edged. It helps edged to get ConfigMaps and secret details from metamanager or cloud.\nIt also sends sync messages, node status and pod status towards metamanger to cloud."))}p.isMDXComponent=!0},82552:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/configmap-handling-f3c459e5b4d8ae97c45189ce631b014e.png"},45140:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/edged-cri-de51174decc714df04b23053d054f2e8.png"},78254:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/edged-overall-408666281afea812269ae0eb064c2b46.png"},87763:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pleg-flow-bc9c34014148b5a64c3d59ed7756e9cd.png"},38709:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pod-addition-flow-018984a4a4358883d6f7b522eae4f9dc.png"},43652:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pod-deletion-flow-9beabbaf7a2c3c0feac27886f7a54341.png"},53122:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pod-status-manger-flow-50e00dc202a5cb87c9a7ca392a8bf428.png"},53930:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pod-update-flow-5320381b4f544dcb0396c6bda336b3eb.png"},85420:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/query-configmap-from-edged-63fa0877b4c4b043aa75cb148e9474f1.png"},21450:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/query-secret-from-edged-2558f198e519b0999c2c11f9e93f617f.png"},66741:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/secret-handling-6815505fd16a6c1053f508774dba55f6.png"}}]);